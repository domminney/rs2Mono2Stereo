# RS2 Mono2Stereo - Technical Code Documentation

This document provides a detailed technical overview of how the RS2 Mono2Stereo plugin code works, including architecture, algorithms, and implementation details. Generated by Claude Sonnet 4.

## Code Architecture Overview

The plugin follows JUCE's standard architecture with two main components:
- **AudioProcessor** (`RS2Mono2StereoAudioProcessor`): Handles audio processing and parameter management
- **AudioProcessorEditor** (`RS2Mono2StereoAudioProcessorEditor`): Manages the user interface

## File Structure and Responsibilities

### PluginProcessor.h/cpp
Contains the core audio processing logic and parameter definitions.

### PluginEditor.h/cpp
Implements the graphical user interface with custom look-and-feel classes.

## Core Audio Processing Algorithm

### 1. Parameter Management

```cpp
// Safe parameter retrieval with fallback values
template<typename T>
T getParam(const juce::AudioProcessorValueTreeState& params, const char* id, T fallback) {
    auto* p = params.getRawParameterValue(id);
    return p ? p->load() : fallback;
}
```

The plugin uses JUCE's `AudioProcessorValueTreeState` for thread-safe parameter management. Parameters are retrieved safely with fallback values to prevent crashes if parameters are undefined.

### 2. Delay Buffer Implementation

```cpp
constexpr int maxDelayMs = 100;
constexpr int maxDelaySamples = 192000;  // 100ms at 192kHz
float delayBuffer[2][maxDelaySamples] = { {0} };
int delayWriteIndex[2] = {0, 0};
```

**Key Design Decisions:**
- **Fixed-size buffer**: Sized for worst-case scenario (100ms at 192kHz)
- **Per-channel buffers**: Separate delay buffers for stereo processing
- **Circular buffer**: Uses write index with modulo arithmetic for efficiency

### 3. Sample-by-Sample Processing Loop

The main processing happens in the inner sample loop:

```cpp
for (int sample = 0; sample < numSamples; ++sample) {
    // 1. Calculate LFO modulation
    double lfoValue = std::sin(2.0 * juce::MathConstants<double>::pi * lfoPhase);
    lfoPhase += lfoIncrement;
    if (lfoPhase >= 1.0) lfoPhase -= 1.0;
    
    // 2. Modulate delay time
    int modulatedDelaySamples = safeDelaySamples + static_cast<int>(lfoValue * lfoDepthSamples);
    modulatedDelaySamples = std::max(0, std::min(modulatedDelaySamples, maxDelaySamples - 1));
    
    // 3. Write to delay buffer
    delayBuffer[channel][delayWriteIndex[channel]] = inSample;
    
    // 4. Read delayed sample
    int delayReadIndex = delayWriteIndex[channel] - modulatedDelaySamples;
    if (delayReadIndex < 0)
        delayReadIndex += maxDelaySamples;
    float delayedSample = delayBuffer[channel][delayReadIndex];
    
    // 5. Store in parallel buffer
    parallelBuffer.setSample(0, sample, delayedSample);
    
    // 6. Advance write pointer
    delayWriteIndex[channel] = (delayWriteIndex[channel] + 1) % maxDelaySamples;
}
```

**Algorithm Breakdown:**

1. **LFO Generation**: Sine wave oscillator with phase accumulation
2. **Delay Modulation**: LFO value modulates the base delay time
3. **Bounds Checking**: Ensures delay samples stay within buffer limits
4. **Circular Buffer Access**: Write pointer advances, read pointer calculated relative to write position
5. **Wrap-around Handling**: Negative read indices wrap to end of buffer

### 4. Filter Processing

```cpp
juce::dsp::AudioBlock<float> parallelBlock(parallelBuffer);
juce::dsp::ProcessContextReplacing<float> context(parallelBlock);
highPassFilters[channel].process(context);
lowPassFilters[channel].process(context);
```

**Filter Implementation:**
- Uses JUCE's DSP module for IIR filtering
- Filters are updated in real-time based on parameter changes
- Separate filter instances per channel for stereo processing

### 5. Gain and Polarity Processing

```cpp
// Apply parallel gain
parallelBuffer.setSample(0, sample, parallelBuffer.getSample(0, sample) * parallelGain);

// Apply phase flip if enabled
bool phaseFlip = (channel == 0 && phaseFlipLeft) || (channel == 1 && phaseFlipRight);
if (phaseFlip) {
    parallelBuffer.setSample(0, sample, -parallelBuffer.getSample(0, sample));
}

// Apply main gain and mix
channelData[sample] *= mainGain;
channelData[sample] += parallelBuffer.getSample(0, sample);
```

**Signal Chain:**
1. Delayed signal gets parallel gain applied
2. Phase inversion applied per channel based on polarity switches
3. Original signal gets main gain applied
4. Processed signal mixed into original

## Mono Compatibility Algorithm

The mono compatibility is achieved through phase relationships:

```cpp
// Default polarity settings
phaseFlipLeft = false;   // Left channel: normal polarity
phaseFlipRight = true;   // Right channel: inverted polarity
```

**Mathematical Principle:**
- Left output: `original + delayed`
- Right output: `original - delayed` (inverted)
- Mono sum: `(L + R) / 2 = (original + delayed + original - delayed) / 2 = original`
- The delayed components cancel out, leaving only the original signal

## User Interface Implementation

### 1. Custom Knob Look and Feel

```cpp
class CustomKnobLookAndFeel : public juce::LookAndFeel_V4 {
    void drawRotarySlider(...) override {
        // Draw knob background
        g.setColour(juce::Colour(0xff9cbbcb));
        g.fillEllipse(bounds);
        
        // Draw position indicator
        float angle = rotaryStartAngle + sliderPosProportional * (rotaryEndAngle - rotaryStartAngle);
        float tx = cx + tipRadius * std::cos(angle - juce::MathConstants<float>::halfPi);
        float ty = cy + tipRadius * std::sin(angle - juce::MathConstants<float>::halfPi);
        g.fillEllipse(tx - dotSize / 2, ty - dotSize / 2, dotSize, dotSize);
        
        // Draw value text
        g.drawText(valueText, bounds, juce::Justification::centred, false);
    }
};
```

**Design Features:**
- Circular knob with position indicator dot
- Value display in center
- Custom color scheme
- Proportional sizing based on component bounds

### 2. Grid Layout System

```cpp
int gridCols = 4;
int gridRows = 2;
int knobSize = width / (gridCols * 1.5);
int gridSpacingX = (width - (gridCols * knobSize)) / (gridCols + 1);
int gridSpacingY = (height - (gridRows * (knobSize + labelHeight))) / (gridRows + 1);
```

**Layout Algorithm:**
- Calculates component sizes based on window dimensions
- Maintains proportional spacing
- Handles resizing while preserving aspect ratio

### 3. Parameter Attachments

```cpp
delayTimeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(
    audioProcessor.parameters, "delayTime", delayTimeSlider);
```

**Connection System:**
- Each UI control connected to corresponding parameter
- Automatic bidirectional synchronization
- Thread-safe parameter updates

## Memory Management and Performance

### 1. Buffer Management
- **Static allocation**: Delay buffers allocated at compile time
- **No dynamic allocation**: Avoids real-time memory allocation
- **Cache-friendly access**: Sequential memory access patterns

### 2. CPU Optimization
- **Minimal branching**: Reduces CPU pipeline stalls
- **Vectorizable operations**: Simple arithmetic operations
- **Efficient parameter retrieval**: Cached parameter values per block

### 3. Exception Handling
```cpp
try {
    // Audio processing code
} catch (const std::exception& e) {
    buffer.clear();
    juce::Logger::outputDebugString(juce::String("Exception: ") + e.what());
} catch (...) {
    buffer.clear();
    juce::Logger::outputDebugString("Unknown exception");
}
```

**Safety Measures:**
- Exception handling prevents crashes
- Buffer clearing ensures silence on error
- Debug logging for troubleshooting

## Thread Safety Considerations

### 1. Parameter Access
- Uses atomic operations for parameter retrieval
- No direct member variable access from audio thread
- ValueTreeState handles thread synchronization

### 2. Filter State
- Separate filter instances per channel
- No shared state between channels
- Filter coefficients updated safely

### 3. LFO State
```cpp
static double lfoPhase = 0.0;
```
- Single static variable for LFO phase
- Acceptable since it's only accessed from audio thread
- Could be made per-instance for multiple plugin instances

## Sample Rate Handling

### 1. Dynamic Adaptation
```cpp
int safeDelaySamples = std::min((int)(safeDelayTime * getSampleRate() / 1000.0), maxDelaySamples - 1);
double lfoIncrement = lfoRateHz / getSampleRate();
```

**Sample Rate Scaling:**
- Delay time converted to samples using current sample rate
- LFO frequency scaled to sample rate
- Filter coefficients updated in `prepareToPlay()`

### 2. Buffer Sizing
- Buffer sized for maximum expected sample rate (192kHz)
- Works efficiently at all lower sample rates
- Wastes some memory at lower rates but ensures compatibility

## Error Handling and Robustness

### 1. Parameter Bounds Checking
```cpp
double safeDelayTime = std::max(0.0, std::min((double)delayTime, maxDelayMs));
modulatedDelaySamples = std::max(0, std::min(modulatedDelaySamples, maxDelaySamples - 1));
```

### 2. Channel Validation
```cpp
if (totalNumInputChannels < 1 || totalNumInputChannels > 2) {
    for (int channel = 0; channel < totalNumInputChannels; ++channel)
        buffer.clear(channel, 0, buffer.getNumSamples());
    return;
}
```

### 3. Fallback Values
- All parameter retrievals have sensible defaults
- Plugin continues to function even with corrupted parameter data
- Graceful degradation rather than crashes

## Future Enhancement Opportunities

### 1. Performance Optimizations
- SIMD vectorization for sample processing
- Look-ahead processing for smoother parameter changes
- More efficient LFO implementations (table lookup)

### 2. Feature Extensions
- Multiple LFO waveforms
- Tempo synchronization
- Stereo width control
- Additional filter types

### 3. Code Structure Improvements
- Separate DSP classes for better modularity
- Template-based parameter system
- More sophisticated state management

---

This technical documentation provides insight into the implementation details and design decisions behind the RS2 Mono2Stereo plugin code.
